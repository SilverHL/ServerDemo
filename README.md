#组织一下这个所谓的负载均衡服务器的架构

首先是log类 这个属于是工具类 主要是 如果有什么问题出现 可以调用这个工具类将出错的信息或者进行的操作打印出来

然后是fdwrapper类 这个是将对fd的操作封装起来 这个底层其实就是用epoll来管理 然后可以将目标描述符

可以是客户端也可以是服务器端的socketfd在epoll中的加入以及删除操作 也没什么麻烦的

在之后是一个抽象出来的类 这个类用来表示服务器端与客户端的连接 其中包括两端的socket 以及两端的缓冲区 

通过对这两个缓冲区 的index进行操作 来记录读写的位置 并通过recv和send来向各自发送信息

然后就是mgr类 这个类主要是用于 一些 对conn连接的实体类的操作 包括连接到server 断开连接 将端口释放

主要用了map来进行fd和连接的映射 并可以将fd循环利用

mgr不过是将线程池中对底层服务器与客户端的信息传递的操作封装起来了

#说一下这个信号处理的调用链 

##先是对set_up_pipe的调用
    
有一个全局的'sig_pipefd[2]'是用来进行信号的通信 调用的也是socketpair这个方法 

    首先是'setup_sig_pipe' 在这个方法中建立管道进行通信 然后 将读端监听 即调用 'add_read_fd' 将读端的
    
    描述符加入到epoll的监听队列中 然后是设置 对部分信号捕捉 如果有子进程发生变化或者进程退出 都会将

    这个信号传递给父进程

##然后是一个死循环  (当然这个死循环会因为进程池内部的m_stop设置成true而停止)

    首先等待epoll中部分时间就绪 返回数量 调用'epoll_wait'

    然后遍历epoll_event数组 挨个判断是否有目标events 如果

